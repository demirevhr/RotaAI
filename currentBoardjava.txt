package uni.ai.rota;

import java.util.List;
import java.util.Scanner;

class ComputerPlayer extends Player {
    private char opponentSymbol;
    ComputerPlayer(RotaBoard board, Scanner scanner, char symbol) {
        super(board, scanner, symbol);
    }
    ComputerPlayer(RotaBoard board, Scanner scanner, char symbol, char opponentSymbol) {
        super(board, scanner, symbol);
        this.opponentSymbol = opponentSymbol;
    }

    void setOpponentSymbol(char s) {this.opponentSymbol = s;}

    Move getMove() {
        board.checkWinner();
        int emptySpaces = board.numberOfEmptySpaces();
        RotaBoard mockBoard = new RotaBoard(board);
        int[] result = minimax(mockBoard, emptySpaces, symbol, Integer.MIN_VALUE, Integer.MAX_VALUE);
        return new Move(result[1], result[2]);
    }

    private int[] minimax(RotaBoard mockBoard, int depth, char player, int alpha, int beta) {
        List<Move> possibleMoves = mockBoard.getAvailableMoves(player);
        int score;
        int bestFrom = -1;
        int bestTo = -1;

        if (possibleMoves.isEmpty() || depth == 0) {
            score = h(mockBoard.getState());
            return new int[] {score, bestFrom, bestTo};
        }
     
        for (Move move : possibleMoves) {
            mockBoard.makeMove(move, player);
            if (player == symbol) {  // computer is maximizing player
                score = minimax(mockBoard, depth - 1, opponentSymbol, alpha, beta)[0];
                if (score > alpha) {
                    alpha = score;
                    bestFrom = move.getFrom();
                    bestTo = move.getTo();
                }
            } else {  // opponent is minimizing
                score = minimax( mockBoard, depth - 1, symbol, alpha, beta)[0];
                if (score < beta) {
                    beta = score;
                    bestFrom = move.getFrom();
                    bestTo = move.getTo();
                }
            }

            if (move.getFrom() == move.getTo()) {
                mockBoard.clearMove(move);
            } else {
                mockBoard.makeMove(new Move(move.getTo(), move.getFrom()), player);
            }

            if (alpha >= beta) break;
        }
        return new int[] {(player == symbol) ? alpha : beta, bestFrom, bestTo};

    }

    private int h(Space[] state) {
        int score = 0;
        for (int i = 0; i < RotaBoard.NUM_LINES; i++) {
            score += evaluateLine(state, RotaBoard.LINES[i][0],
                                         RotaBoard.LINES[i][1],
                                         RotaBoard.LINES[i][2]);
        }
        return score;
    }

    private int evaluateLine(Space[] state, int s1, int s2, int s3) {
        int score = 0, numComp = 0, numOpponent = 0;

        if (state[s1].getSymbol() == symbol) {
            ++numComp;
        } else if (state[s1].getSymbol() == opponentSymbol) {
            ++numOpponent;
        }

        if (state[s2].getSymbol() == symbol) {
            ++numComp;
        } else if (state[s2].getSymbol() == opponentSymbol) {
            ++numOpponent;
        }

        if (state[s3].getSymbol() == symbol) {
            ++numComp;
        } else if (state[s3].getSymbol() == opponentSymbol) {
            ++numOpponent;
        }

        if (numOpponent == 0) {
            if (numComp == 2) {
                score += 2;
            } else if (numComp == 1) {
                score += 1;
            }
        }

        if (numComp == 0) {
            if (numOpponent == 2) {
                score -= 2;
            } else if (numOpponent == 1) {
                score -= 1;
            }
        }
        return score;
    }
}
